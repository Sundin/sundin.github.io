<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Master of Software Engineering</title><link>/categories/Testing/</link><description>Recent content in Testing on Master of Software Engineering</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 07 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="/categories/Testing/feed.xml" rel="self" type="application/rss+xml"/><item><title>Testing: Best Practices</title><link>/post/2019-08-07-testing-best-practices/</link><pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate><guid>/post/2019-08-07-testing-best-practices/</guid><description>In this post I will describe a number of best practices I find useful to keep in mind when writing tests. It is intended to act as a complement to my previous post, [A successful testing strategy]({{ site.baseurl }}{% post_url 2019-06-26-a-successful-testing-strategy %}).
Code coverage &amp;ldquo;100% code coverage tells you nothing, but less than 100% code coverage tells you something.&amp;rdquo;
– Unknown Aiming for covering 100% of your code with tests is probably not realistic and perhaps not very useful neither.</description></item><item><title>A Successful Testing Strategy</title><link>/post/2019-06-26-a-successful-testing-strategy/</link><pubDate>Wed, 26 Jun 2019 13:00:07 +0000</pubDate><guid>/post/2019-06-26-a-successful-testing-strategy/</guid><description>Today we will a closer look at the classic testing pyramid and see how we can transform that into a concrete strategy for how to write your tests. While the terminology I use is not exactly the same as the one used by Mike Cohn when he first described the testing pyramid in his book Succeeding with Agile, the core concepts remain the same – a strong foundation of unit tests, complemented with a sufficient number of component tests (which are similar to Cohn&amp;rsquo;s service tests) and sprinkled with a few end-to-end tests (which are called UI tests by Cohn) as a last line of defense.</description></item><item><title>Dockerized database testing</title><link>/post/2019-03-29-dockerized-db-tests/</link><pubDate>Fri, 29 Mar 2019 11:11:30 +0000</pubDate><guid>/post/2019-03-29-dockerized-db-tests/</guid><description>In this post I am going to give you an overview of different approaches to use when unit testing your backend code and database calls.
Background In my current project, we have a backend written in Go and a PostgreSQL database. We have for a long time been writing unit tests for the backend to be able to guarantee that the code is working as intended. In order to not have to rely on a database connection and be dependent on the state of the data in that database, we chose to mock away all database calls using a tool called go-sqlmock in the unit tests.</description></item></channel></rss>