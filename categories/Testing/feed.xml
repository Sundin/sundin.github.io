<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Master of Software Engineering</title><link>/categories/Testing/</link><description>Recent content in Testing on Master of Software Engineering</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Jun 2022 00:00:01 +0000</lastBuildDate><atom:link href="/categories/Testing/feed.xml" rel="self" type="application/rss+xml"/><item><title>End-to-end testing field guide</title><link>/e2e-testing-field-guide/</link><pubDate>Tue, 21 Jun 2022 00:00:01 +0000</pubDate><guid>/e2e-testing-field-guide/</guid><description>This is a beginner&amp;rsquo;s guide to getting started with end-to-end (E2E) testing. It is intended to be read as a high level overview of best practices, as there are already plenty of great and detailed tutorials on various frameworks &amp;ldquo;out there&amp;rdquo; on the Internet. This guide uses Cypress as the example testing framework (just because it&amp;rsquo;s the one I use the most), but the same methodology as described here can be applied using any framework.</description></item><item><title>Robust end-to-end testing with Docker Compose</title><link>/e2e-tests-with-docker-compose/</link><pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate><guid>/e2e-tests-with-docker-compose/</guid><description>End-to-end (E2E) testing is a powerful tool for automated quality assurance. Ideally you want to be able to catch potential errors and bugs already on the unit testing level, but doing so can sometimes be both time-consuming and difficult. Unit testing also relies heavily on mocking out dependencies by nature, so we cannot necessarily guarantee the same behaviour as in our live application. E2E tests are on the other hand often very straightforward to set up and write, and enables us to construct very realistic testing scenarios.</description></item><item><title>Testing: Best Practices</title><link>/testing-best-practices/</link><pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate><guid>/testing-best-practices/</guid><description>In this post I will describe a number of best practices I find useful to keep in mind when writing tests. It is intended to act as a complement to my previous post, A successful testing strategy.
Code coverage &amp;ldquo;100% code coverage tells you nothing, but less than 100% code coverage tells you something.&amp;rdquo; – Unknown
Aiming for covering 100% of your code with tests is probably not realistic and perhaps not very useful neither.</description></item><item><title>A Successful Testing Strategy</title><link>/successful-testing-strategy/</link><pubDate>Wed, 26 Jun 2019 13:00:07 +0000</pubDate><guid>/successful-testing-strategy/</guid><description>Today we will a closer look at the classic testing pyramid and see how we can transform that into a concrete strategy for how to write your tests. While the terminology I use is not exactly the same as the one used by Mike Cohn when he first described the testing pyramid in his book Succeeding with Agile, the core concepts remain the same – a strong foundation of unit tests, complemented with a sufficient number of component tests (which are similar to Cohn&amp;rsquo;s service tests) and sprinkled with a few end-to-end tests (which are called UI tests by Cohn) as a last line of defense.</description></item><item><title>Dockerized database testing</title><link>/dockerized-db-tests/</link><pubDate>Fri, 29 Mar 2019 11:11:30 +0000</pubDate><guid>/dockerized-db-tests/</guid><description>In this post I am going to give you an overview of different approaches to use when unit testing your backend code and database calls.
Background In my current project, we have a backend written in Go and a PostgreSQL database. We have for a long time been writing unit tests for the backend to be able to guarantee that the code is working as intended. In order to not have to rely on a database connection and be dependent on the state of the data in that database, we chose to mock away all database calls using a tool called go-sqlmock in the unit tests.</description></item></channel></rss>