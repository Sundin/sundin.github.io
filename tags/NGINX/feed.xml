<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NGINX on Master of Software Engineering</title><link>/tags/NGINX/</link><description>Recent content in NGINX on Master of Software Engineering</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Oct 2021 10:58:32 +0200</lastBuildDate><atom:link href="/tags/NGINX/feed.xml" rel="self" type="application/rss+xml"/><item><title>Introducing Frontman</title><link>/Introducing-Frontman/</link><pubDate>Mon, 04 Oct 2021 10:58:32 +0200</pubDate><guid>/Introducing-Frontman/</guid><description>Frontman is a very light-weight NGINX reverse proxy that is deployed using Docker. Its purpose is to act as the entry point to your server. It will redirect incoming traffic to one out of many Docker-based applications running on the same server, based on the hostname in the incoming request.
The rationale behind this is that it enables you to host as many services as you want on the same server, while still only keeping ports 80 and 443 open to the outside world.</description></item><item><title>Runtime Environment Variables in the Browser</title><link>/runtime-env-vars/</link><pubDate>Wed, 30 Jun 2021 10:58:32 +0200</pubDate><guid>/runtime-env-vars/</guid><description>A limitation to all web development frameworks is that environment variables has to be injected during build time in order to made be available in the browser. If we have packaged our web application using Docker, that means that we would need to build a different container image for each different environment where we will want to host our application. This is a waste of resources and also introduces a risk of us ending up with a different codebase in our production environment than what we tried out in our QA or test environment.</description></item><item><title>How to Build a Reverse Proxy</title><link>/nginx-reverse-proxy/</link><pubDate>Mon, 28 Jun 2021 10:58:32 +0200</pubDate><guid>/nginx-reverse-proxy/</guid><description>In this blog post I will describe how you can deploy services on the same server. The server will be fronted by an NGINX instance acting as a reverse proxy responsible for forwarding incoming traffic to the right service.
I will use an EC2 instance on AWS since it has a low monthly cost and I don&amp;rsquo;t have to worry about hardware maintenance at all, but you can use the same approach for any kind of server.</description></item></channel></rss>